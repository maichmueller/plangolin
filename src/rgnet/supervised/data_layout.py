import dataclasses
import enum
from pathlib import Path
from typing import Iterator, Optional

from rgnet.supervised import MultiInstanceSupervisedSet


class DatasetType(str, enum.Enum):
    TRAIN = "train"
    EVAL = "eval"
    TEST = "test"


@dataclasses.dataclass
class DataLayout:
    """Encapsulates logic where to store what.
    Additionally, file-name-conventions / translations are provided.
    If there is some problem.pddl then we expect the serialized file to be
     problem_states.txt and a plan file to be problem.pddl.plan
    """

    def __init__(
        self,
        data_path: str,
        domain_name: str,
        encoder_type: str,
        subs_missing_okay: bool = True,
    ):
        """
        Folder structure:

        :type data_path: str The name of the domain, e.g. blocks.
        :type encoder_type: str The encoder type as passed to run_supervised::run
        :type subs_missing_okay: bool Whether it okay that subdirectories below the
        data_path can be missing, e.g. 'pddl_domains' or 'datasets'.

        data_path
            - pddl_domains
                - <domain-name>
                    - domain.pddl
                    - train
                        - problem1.pddl
                        - ...
                    - eval
                    - test
            - datasets
                - <encoding_type>
                    - <domain-name>
                        - train #  root dir of dataset
                            - processed
                            - raw
                        - eval
                        - test
            - models
                - <encoding_type>
                    - <domain-name>
                        - <run-id>
                            - checkpoint.ckpt
            - serialized
                - <domain-name>
                    - train
                        - problem1_states.txt
                        - ...
                    - eval
                    - test
            - plans
                 <domain-name>
                    - train
                        - problem1.pddl.plan
                        - ...
                    - eval
                    - test


        """
        if data_path[-1] == "/":  # remove training slash
            data_path = data_path[:-1]
        self.data_path = Path(data_path)

        self.domain_name: str = domain_name
        self.encoder_type: str = encoder_type
        self._subs_missing_okay: bool = subs_missing_okay
        # define paths
        if not self.data_path.is_dir():
            raise ValueError(
                f"Data path ({data_path}) does not exist or is not a directory."
            )
        self.problem_path: Path = self.data_path / "pddl_domains" / domain_name
        self.domain_file_path: Path = self.problem_path / "domain.pddl"
        self.dataset_path: Path = (
            self.data_path / "datasets" / encoder_type / domain_name
        )
        # Model save path
        self.model_save_path: Path = Path(
            f"{data_path}/models/{encoder_type}/{domain_name}/"
        )
        # Where to store optimal plans (typically generated by fast-downward)
        self.plans_path: Path = Path(f"{data_path}/plans/{domain_name}/")

        self.serialized_path: Optional[Path] = (
            self.data_path / "serialized" / domain_name
        )

        # Create folder structure for datasets if absent
        if subs_missing_okay:
            self.dataset_path.mkdir(parents=True, exist_ok=True)
            self.model_save_path.mkdir(parents=True, exist_ok=True)
            self.serialized_path.mkdir(parents=True, exist_ok=True)
            self.plans_path.mkdir(parents=True, exist_ok=True)
        else:
            assert self.dataset_path.is_dir()
            assert self.model_save_path.is_dir()
            # Plan path and serialized path are not necessary for many problems

    def load_checkpoints(self, run_id: str) -> Iterator[Path]:
        ckpt_path = self.model_save_path / run_id
        if not ckpt_path.exists():
            raise ValueError(
                f"Could not find directory for run id ({run_id})"
                f"at: {self.model_save_path / run_id}"
            )
        return ckpt_path.glob("*.ckpt")

    def load_dataset(self, set_type: DatasetType) -> MultiInstanceSupervisedSet:
        path = self.dataset_path_for(set_type)
        return MultiInstanceSupervisedSet.load_from(str(path.absolute()))

    def dataset_path_for(self, set_type: DatasetType):
        return self.dataset_path / set_type.value

    def problems_path_for(self, set_type: DatasetType):
        return self.problem_path / set_type.value

    def problems_paths_for(self, set_type) -> Iterator[Path]:
        path = self.plans_path / set_type.value
        return filter(lambda f: f.stem != self.domain_name, path.glob("*.pddl"))

    def plans_paths_for(self, set_type) -> Iterator[Path]:
        if not self.plans_path.is_dir():
            raise ValueError(
                "No planning directory found : " + str(self.plans_path.absolute())
            )
        path = self.plans_path / set_type.value
        return path.glob("*.plan")

    def problem_for_plan(self, plan_file: Path, set_type: DatasetType) -> Path:
        # Excepts plans to have the exact name of the problem with .plan as file suffix
        problem_path: Path = self.problem_path / set_type.value / plan_file.stem
        if not problem_path.is_file():
            raise ValueError("Problem not found: " + str(problem_path.absolute()))
        return problem_path

    def serialized_paths_for(self, set_type) -> Iterator[Path]:
        if not self.serialized_path.is_dir():
            raise ValueError(
                "No serialized directory found: " + str(self.plans_path.absolute())
            )
        path = self.serialized_path / set_type.value
        return path.glob("*_states.txt")

    def problem_for_serialized(
        self, serialized_file: Path, set_type: DatasetType
    ) -> Path:
        # Excepts serialized files to have the name of the problem with _states.txt
        # instead of .pddl as suffix. E.g. problem_states.txt for problem.pddl
        problem_name = serialized_file.stem.removesuffix("_states") + ".pddl"
        problem_path: Path = self.problem_path / set_type.value / problem_name
        if not problem_path.is_file():
            raise ValueError("Problem not found: " + str(problem_path.absolute()))
        return problem_path
